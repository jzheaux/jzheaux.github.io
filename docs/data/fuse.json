{"keys":[{"path":["title"],"id":"title","weight":1,"src":"title","getFn":null},{"path":["body"],"id":"body","weight":1,"src":"body","getFn":null}],"records":[{"i":0,"$":{"0":{"v":"This page has not yet sprouted","n":0.408},"1":{"v":"[Dendron](https://dendron.so/) (the tool used to generate this site) lets authors selective publish content. You will see this page whenever you click on a link to an unpublished page\n\n![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/not-sprouted.png)","n":0.189}}},{"i":1,"$":{"0":{"v":"Home","n":1},"1":{"v":"\nWelcome to my space for personal musings about coding, cybersecurity, AI, and at times philosophy.","n":0.258}}},{"i":2,"$":{"0":{"v":"Spring Security","n":0.707}}},{"i":3,"$":{"0":{"v":"Tips","n":1},"1":{"v":"\n## Authorization\n\nEveryone wants to create their own API, and that makes sense. We want our app to look like our domain.\n\nHistorically, Spring Security has one way to do this: SpEL.\nIt's done by publishing a custom `MethodSecurityExpressionHandler`, which handler returns a `SecurityExpressionRoot` instance that has the application's custom expressions.\nThis allows the application to do:\n\n```java\n@PreAuthorize(\"isSubscribed() || isAdmin()\")\n```\n\nWhile I appreciate the readability of this, I'd prefer something more like the following:\n\n```java\n@Authorize({ Subscribed.class, Admin.class })\n```\n\nThis is more testable because I can have unit tests for `Subscribed.class` and for `Admin.class`.\n\nSo, how do we achieve that?\n\nFirst, create the annotation:\n\n```java\n@PreAuthorize(\"permitAll()\")\npublic @interface Authorize {\n    Class<? extends AuthorizationManager<MethodInvocation>> any() default {};\n}\n```\n\nSecond, create an interceptor:\n\n```java\n@Component\npublic final class AuthorizeAuthorizationManager implements AuthorizationManager<MethodInvocation> {\n    private final SecurityAnnotationScanner authorize = SecurityAnnotationScanners.fromAnnotation(Authorize.class);\n    private final Map<Class<?>, AuthorizationManager<MethodInvocation>> cache = new HashMap<>();\n\n    @Override\n    public AuthorizationDecision check(Supplier<Authentication> authentication, MethodInvocation invocation) {\n        Authorize authorize = this.authorize.scan(invocation, invocation.getDeclaringClass());\n        if (authorize == null) {\n            return null;\n        }\n        return AuthorizationManagers.anyOf(Stream.of(authorize.any()).map(this::manager).toList());\n    }\n\n    private AuthorizationManager<MethodInvocation> manager(Class<?> clazz) {\n        return this.cache.computeIfAbsent(clazz, this::newInstance);\n    }\n\n    private <T> T newInstance(Class<?> clazz) {\n        try {\n            return this.cache.computeIfAbsentclazz.newInstance();\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n}\n```\n\nAnd then finally, publish an interceptor:\n\n```java\n@Bean(ROLE_INFRASTRUCTURE)\nstatic MethodInterceptor authorizeInterceptor(AuthorizeAuthorizationManager authorize) {\n    var interceptor = AuthorizationManagerBeforeMethodInterceptor.preAuthorize(authorize);\n    interceptor.setOrder(AuthorizeInterceptorOrder.PRE_AUTHORIZE - 1);\n    return interceptor;\n}\n```\n\nThis allows you to unit-test the authorization classes and get compile-time feedback on authorization expressions.","n":0.069}}},{"i":4,"$":{"0":{"v":"Polish","n":1},"1":{"v":"\nA place where I model various polishes that I'd recommend for applications using Spring Security.","n":0.258}}},{"i":5,"$":{"0":{"v":"Pluralsight","n":1}}},{"i":6,"$":{"0":{"v":"LLM Frameworks","n":0.707},"1":{"v":"\nDetails about my upcoming course regarding LLM Frameworks, specifically using Spring AI to create an AI Agent.","n":0.243}}}]}
